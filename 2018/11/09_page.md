## ArrayList와 LinkedList 차이

 - ArrayList는 고정되지 않은 배열이라 생각 하면 되며 검색은 빠르지만 삽입, 삭제시 정렬이 발생하여 느리다.
 - LinkedList는 삽입, 삭제는 빠르지만 검색은 느리다.

****

## Quartz 스레드 동시접근 이슈 및 뮤텍스(잠금장치) 구현 사례

### 상황
스레드풀 환경에서 1개의 Job이 오직 1개의 스레드만 접근할 것이라는건 나의 큰 착각이었다...   
10개의 스레드풀 안에 각각의 스레드가 Timed Waiting 상태 즉, 언제든지 다시 실행 될 수 있는 상태에서 Batch를 등록하게 되면 여러 스레드가 기다렸다는 듯이 동시에 Job(Runnable)을 실행시켜 DB에 같은 데이터가 Insert 되어 데이터 중복이 발생하였다.


### 원인
멀티스레드 환경에서는 하나의 공유 자원을 접근 할 수 있음


### 해결
OS를 공부하면서 알게 된 세마포어와 뮤텍스가 생각나서 이미 선점한 스레드가 문을 잠그는 방식을 떠올려 Java로 구현하여 현상 해결함


### 알게된점
스레드풀에 단점을 피부로 느꼈다.
스레드풀은 미리 스레드를 여러개 생성해 놓는데 실제 사용되는 스레드가 1개라면 나머지는 놀게 되고 그 만큼 불필요한 메모리를 점유하는데 이런 단점을 보안하는 방식인 **ForkJoinPool** 이 있다고 하는데 반드시 이것도 적용해보자


### 앞으로는??
스레드풀 환경에서는 동시에 스레드가 하나의 자원, 객체를 접근 할 수 있음을 꼭 인지 하고 그에 따른 베타제어 처리가 필요함을 무겁께 느껴야 함..  
동시 처리가 필요하다면 비동기 방식도 고려해 보기



## Quartz 클러스터링 사용기
드디어 성공..!! 하고 있는 프로젝트에 quartz를 선택한 이유는 바로 클러스터링 기능때문이었다.  
모호하기만 했던 내용이 실제 눈앞에서 동작 되니까 너무 재미있었다.  기능은 아래와 같다.  
- 서버 이중화 (1,2 서버) 되어 있을 때 1번서버 죽으면 2번서버가 1번 서버것 까지 맡아 스케줄링 해줌  
  + 상세동작  
  -> 1서버 shutdown  
  -> 2서버 shutdown detected  
  -> 2서버 1서버것 까지 같이 running  
  -> 1서버 was start (복구됨)  
  -> 2서버 1서버에서 맡은것 중지  
  -> 1서버에서 맡았던 배치 다시 running  

- 각각 서버별 스케줄링을 나누어서 할 수 있음 (클러스터링)  

****

## 앞으로 남은 것
- ThreadPool 단점을 보안 해 줄 수 있다는 ForkJoinPool을 사용해서 단점이 극복 되는지 확인해보자
- spring batch 연동하여 spring batch를 사용함으로써 좋은점 알아내기
- spring partitioning 사용하여 데이터 merge 속도 개선
